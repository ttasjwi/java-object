
# Object-Theater
- 오브젝트 1장을 보고 얻은 키워드들 정리

---

## 패러다임

### 절차적 프로그래밍(Procedural Programming)
   - 데이터, 프로세스로 구성되어 있다.
   - 데이터와 데이터를 사용하는 프로세스가 별도의 객체에 위치해 있는 경우도 절차지향 프로그래밍 방식을 따르는 것일 가능성이 높다.
   - 프로세스를 수행하기 위해서 필요한 모든 데이터에 접근이 열려있다. 의존하는 데이터, 프로세스가 있을 때, 이들의 변경은 프로세스의 변경을 야기한다. 직접적으로 내부적인 데이터, 프로세스들을 의존해서 그대로 절차적으로 처리하기 때문에 각각의 의존 관계가 변경되면 프로세스 전체의 변경 가능성이 매우 높아지고 유지 보수성이 떨어진다.

### 객체지향 프로그래밍(Object-Oriented Programming)
   - 데이터, 프로세스가 동일한 모듈 안에 구성
   - 자율적이고 능동적인 객체들의 협력.
   - 객체는 '어플리케이션'이라는 공동체 속에서, 자신에게 주어진 책임에 맞게 자기 자신을 스스로 책임지고 다른 구성원 객체가 요청할 때 자기 나름대로 응답할 수 있어야한다.
   - 스스로 응답할 수 없거나 자신의 책임과 무관한 일은 그 역할을 책임진 객체에게 위임하여 서로 협력하면 된다. 
   - 각각의 객체들에게 적절한 책임을 분리하고, 객체별로 최소한의 의존관계를 부여하여 변경의 이유를 최소화 
   - 객체는 스스로 자기에게 맡겨진 일을 책임지기 때문에 외부에서 굳이 알 필요 없는 내부적인 속 사정은 공개하지 않는다.

---

## 의존성과 결합도

### 의존성(Dependency)
- 의존성(dependency) : 어떤 모듈이 기능을 수행하기 위해 다른 모듈의 특정 기능을 사용해야할 때 이런 관계를 의존관계라고 함. 
  - 예1) MemberController -> MemberQueryService, MemberCommandService 
  - 예2) MemberService -> MemberRepository
- 어떤 객체가 변경될 때 그 객체를 의존하는 다른 객체도 함께 변경될 수 있는 위험이 존재함.
- 많은 클래스를 의존하고 있다는 것은, 각 클래스의 변경이 일어날 때마다 변경이 일어날 수 있다는 것을 의미.

### 결합도(Coupling)
- 어떤 모듈이 다른 모듈에 의존하는 정도 
- 결합도가 높다 : 객체 사이의 의존성이 과한 것을 의미함. 두 객체의 결합도가 지나치가 높으면 함께 변경될 가능성도 높아지고, 유지보수가 힘들어진다. 
- 결합도가 낮다 : 객체들이 합리적인 수준으로 최소한의 의존 관계를 형성한 경우를 의미함. 객체의 내부 속사정을 외부에서 불필요하게 알도록 하지 않게 최소한의 표면적인 인터페이스(역할)에 의존하게 하여 변경 가능성을 최소화하는 것.

---

## 책임의 분리를 통해 결합도를 낮추고 응집도를 높여라.

### 책임의 이동(shift of responsibility)
- 공동체(어플리케이션)를 구성하는 객체에게 적절한 책임을 분배, 할당하고, 각 객체가 자신을 스스로 책임지도록 하는 것
- 적절한 객체에게 적절한 책임을 할당하고 응집도를 높이는 것.

### 응집도(cohesion)

- 모듈의 모듈 내부의 처리 요소들이 서로 관련되어 있는 정도
- 응집도가 높은 객체 : 밀접하게 연관된 작업만을 수행하고, 연관성 없는 작업은 다른 객체에 위임하는 객체

---

## 캡슐화 : 필요한 인터페이스만 공개하고 내부 구현을 감춰라.

### 캡슐화(encapsulation)
- 개념적으로, 물리적으로 객체 내부적으로만 알고 있어도 되는 세부적인 사항을 은닉하는 것
- 캡슐화의 목적 : 변경하기 쉬운 객체를 만드는 것.
- 내부적인 상태, 메서드로의 불필요한 접근을 제한함으로서 객체 사이의 결합도를 낮출 수 있고, 객체의 자율성을 높임으로서 설계를 좀 더 쉽게 변경할 수 있음

### 인터페이스(interface)와 구현(implementation)
- 인터페이스(interface) : 표면적으로 노출된 경계면, 역할.
- 구현(implementation) : 내부적으로 객체 스스로가 가지고 있는 속사정, 주어진 역할, 요청을 자율적으로 처리하는 객체 나름의 자율적인 행동 방식.
- 불필요한 내부 구현을 공개하는 경우(특히 getter)는 대개 객체가 스스로 처리할 수 있는 로직을 외부에 떠넘기는 경우가 많음. 이는 응집도를 낮추고 결합도를 높이는 결과를 낳아 유지보수성이 좋지 않은 코드가 될 가능성이 많다.

---
## 객체들이  스스로를 책임지고 자율적으로 행동하게 하라. 심지어 무생물이라도!!!

### 의인화(Anthropomorphism)
- 능동적이고 자율적인 존재로 소프트웨어 객체를 설계하는 원칙 
- 아무리 현실세계에서 수동적인 존재일 지라도 능동적이고 자율적인 존재로 구현하는 것.

### 자율성(autonomy)
- 객체가 자기 자신에게 주어진 책임에 대해서 스스로 능동적으로 책임질 수 있는 것
- 필요한 인터페이스만 공개하고, 불필요한 내부적인 사정을 감추는 캡슐화를 통해 자율성을 보장할 수 있음.

---

##  좋은 설계
- 오늘 요구하는 기능은 온전히 수행하면서, 내일의 변경(요구사항의 변경)은 매끄럽게 수용할 수 있는 설계
- 변경에 유연하게 대응할 수 있고, 이해하기 쉬운 코드

### 좋은 객체지향 설계
- 세상을 바라보는 방식 그대로 코드를 작성할 수 있도록 하는 것.
- 객체 스스로 자신의 데이터를 책임지고, 서로 메시지를 통해 상호작용하는 코드를 작성하는 것
- 객체 간의 의존성을 '적절하게' 조절하여, 변경에 용이한 설계를 만드는 것
  - 객체간의 상호작용은 객체 사이에 주고 받는 메시지로 표현.
  - 다른 객체에 메시지를 주고 응답받으려면, 그 객체에 대한 지식을 알고 있어야함. 메시지를 전송하기 위한 지식이 두 객체를 결합시키고, 이 결합이 객체간 의존성을 만듬. 객체간 의존성은 애플리케이션을 수정하기 어렵게 만듬

---
